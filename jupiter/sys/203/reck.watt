=>  |%
    ++  shoe                              ::  trace stack layer
      $%  [%bean p=*]                     ::  raw noun
          [%lose p=term]                  ::  error message
          [%mean p=_|.(*tank)]            ::  prettyprint trigger
          [%pray p=path]                  ::  prayer attempt
          [%spot p=spot]                  ::  source position
      ==
    --
=>  |%
    ++  swan
      |=  yos=shoe  ^-  tank
      ?-  -.yos
        %bean  (show %q p.yos)
        %lose  (show %t p.yos)
        %mean  $:p.yos
        %pray  (show %h p.yos)
        %spot  (show %o p.yos)
      == 
    ::
    ++  visc
      |=  typ=type  ^-  tank 
      (dial:ut ~(dole ut typ))
    ::
    ++  vise
      |=  vax=vase  ^-  tank
      (dish:ut ~(dole ut p.vax) q.vax)
    ::
    ++  wash
      |=  [[tab=@ edg=@] tac=tank]  ^-  wall
      (~(win re tac) tab edg) 
    --
=>  |%
    ++  beef  ,*                              ::  application event
    ++  bill  ,[p=date q=*]
    ++  brig  $,  :-  o=(unit bill) 
                  v=(map span brig)
    ++  date  time
    ++  fact  ,[p=path q=*]
    ++  kiwi                                  ::  system product
      $%  [%o p=@ta q=*]                      ::  opaque output by app
          [%p p=@ud q=@ud r=tank]             ::  print session, tab, etext
          [%w p=date]                         ::  request wake at date
      ==
    ++  lamb                                  ::  system event
      $|  ~                                   ::  wakeup
      $%  [%d p=(list ,[p=term q=plum])]      ::  direct output
          [%e p=(list ,[p=term q=pork])]      ::  direct input
          [%l p=@ud q=@ta]                    ::  command line by session
      ==
    ++  lens                                  ::  query interface
      $_  ^?
      |%
      ++  pray  |+([date path] *(unit bill))  ::  special query
      ++  wish  |+(quay *brig)                ::  general query
      --
    ++  pane  $|(date [p=date q=date])        ::  date after/on or before
    ++  plum                                  ::  process product
      $%  [%po p=path q=*]                    ::  post to sequence
          [%pu p=path q=*]                    ::  put in deck
          [%to p=@ta q=beef]                  ::  pass a command
          [%yo p=kiwi]                        ::  output
      ==
    ++  pork                                  ::  process event
      $|  ~                                   ::  no-op
      $%  [%do p=beef]                        ::  direct command
          [%ti p=date]                        ::  time update
          [%nu p=fact]                        ::  new fact
      ==
    ++  quay                                  ::  complex query
      $:  fad=?                               ::  forward/reverse
          wod=(unit pane)                     ::  learned in window
          fig=(unit ,[p=@ud q=@ud])           ::  subset of sequence 
          qud=quid                            ::  functional query
      ==
    ++  quid  (list $|(span _|+(span ?)))
    ++  ship                                  ::  process
      $_  ^?  
      |%
      ++  film                                ::  simple query
        |+  [now=date hip=path]
        *(unit) 
      ::
      ++  step                                ::  assimilate plums
        |+  [now=date cam=lens poc=pork]
        [p=*(list plum) q=^?(..step)]
      --  
    --
|=  who=@h
=+  why=(rent %h who)
=+  deq=[ear=*(map path ,@) rig=*brig]
=+  ^=  pod  ^-  (list ,[p=term q=ship])
    ::  :~  [%bede (hull (weld [why ~] [%bede ~]) #/+bede)]
    ::  ==
    ~
=>  |%                                        ::  internal devices
    ++  iris
      ^-  lens
      |%
      ++  pray  
        |=  [now=date hap=path] 
        ^-  (unit bill)
        !!
      ++  wish  
        |=  qua=quay  
        ^-  brig
        !!
      --
    ++  post                                  ::  add to sequence
      |=  [now=date nam=path val=*]
      ^-  [p=[p=path q=*] q=_..post]
      !!
    ++  putt                                  ::  write as state
      |=  [now=date nam=path val=*]
      ^-  [p=[p=path q=*] q=_..putt]
      !!
    ++  save
      |=  [now=date pie=(list ,[p=@ta q=plum])]
      =+  lod=*(list ,[p=path q=*])
      |-  ^+  [p=lod q=..save]
      ?~  pie
        [(flop lod) ..save]
      ?+    q.i.pie  $(pie t.pie)
          [%po *]  
        =+  von=(post now (weld [why ~] [p.i.pie p.q.i.pie]) q.q.i.pie)
        $(pie t.pie, lod [p.von lod], ..save q.von)
      ::
          [%pu *]
        =+  von=(putt now (weld [why ~] [p.i.pie p.q.i.pie]) q.q.i.pie)
        $(pie t.pie, lod [p.von lod], ..save q.von)
      ==
    ::
    ++  wick
      |=  :*  now=date
              vey=(list pork) 
              sun=(list ,[p=term q=pork]) 
          ==
      ^-  [p=(list kiwi) q=_..wick]
      %+  work  
        now
      |=  [now=date cam=lens nam=@ta ski=ship]
      ^-  [p=(list plum) q=ship]
      =+  ^=  bam
          %+  weld
            vey
          |-  ^-  (list pork)
          ?~(sun ~ =+(yec=$(sun t.sun) ?.(=(nam p.i.sun) yec [q.i.sun yec])))
      =+  yap=*(list (list plum))
      |-  ^-  [p=(list plum) q=ship]
      ?~  bam
        =+  pay=`_yap`(flop yap)
        :-  |-  ^-  (list plum)
            ?~  pay
              ~
            (weld i.pay $(pay t.pay))
        ski
      =+  rez=(step:ski now cam i.bam)
      $(bam t.bam, yap [p.rez yap], ski q.rez)
    ::
    ++  wilt
      |=  [now=date pie=(list ,[p=term q=plum])]
      ^-  [p=(list kiwi) q=_..wilt]
      =+  vad=(save now pie)
      =>  ^+(. .(..work q.vad))
      =-  :-  |-  ^-  (list kiwi)
              ?~  pie
                p.gow
              =+  weg=$(pie t.pie)
              ?.(?=([%yo *] q.i.pie) weg [p.q.i.pie weg])
          q.gow
      ^=  gow
      %^    wick
          +(now)
        |-  ^-  (list pork)
        ?~(p.vad ~ [[%nu i.p.vad] $(p.vad t.p.vad)])
      |-  ^-  (list ,[p=term q=pork])
      ?~  pie 
        ~ 
      =+  der=$(pie t.pie)
      ?.(?=([%to *] q.i.pie) der [[p.i.pie [%do p.q.i.pie]] der])
    ::
    ++  work
      |=  :-  now=date 
          ^=  rap  $_  |+  [now=date cam=lens @ta ski=ship]
                       [p=*(list plum) q=*ship]
      ^-  [p=(list kiwi) q=_..work]
      =+  ^=  pan  ^-  (list ,[p=term q=(list plum) r=ship])
          %+  turn
            pod
          |=  a=[p=term q=ship]
          [p.a (rap now iris p.a q.a)]
      =>  ^+(. .(pod (turn pan |=(a=[p=term q=(list plum) r=ship] [p.a r.a]))))
      %+  wilt
        now
      |-  ^-  (list ,[p=term q=plum])
      ?~  pan
        ~
      |-  ^-  (list ,[p=term q=plum])
      ?~  q.i.pan
        ^$(pan t.pan)
      [[p.i.pan i.q.i.pan] $(q.i.pan t.q.i.pan)]
    --
|%                                            ::  external interface
++  flog
  |=  [now=date lab=lamb]  
  ^-  [p=(list kiwi) q=_..flog]
  =+  cro=|=(did=[p=(list kiwi) q=_..work] [p.did ..flog(..work q.did)])
  ?-    lab
      ~       (cro (wick now [[%do ~] ~] ~))
      [%d *]  (cro (wilt now p.lab))
      [%e *]  (cro (wick now ~ p.lab))
      [%l *]  $(lab [%e [[%bede [%do %line p.lab q.lab]] ~]])
  ==
::
++  read
  |=  [now=date hap=path]
  (pray:iris now hap)
--
