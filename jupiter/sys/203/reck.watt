=>  |%
    ++  shoe                              ::  trace stack layer
      $%  [%bean p=*]                     ::  raw noun
          [%lose p=term]                  ::  error message
          [%mean p=_|.(*tank)]            ::  prettyprint trigger
          [%pray p=path]                  ::  prayer attempt
          [%spot p=spot]                  ::  source position
      ==
    --
=>  |%
    ++  swan
      |=  yos=shoe  ^-  tank
      ?-  -.yos
        %bean  (show %q p.yos)
        %lose  (show %t p.yos)
        %mean  $:p.yos
        %pray  (show %h p.yos)
        %spot  (show %o p.yos)
      == 
    ::
    ++  visc
      |=  typ=type  ^-  tank 
      (dial:ut ~(dole ut typ))
    ::
    ++  vise
      |=  vax=vase  ^-  tank
      (dish:ut ~(dole ut p.vax) q.vax)
    ::
    ++  wash
      |=  [[tab=@ edg=@] tac=tank]  ^-  wall
      (~(win re tac) tab edg) 
    --
=>  #/+deck
=>  |%
    ++  beef  ,*                              ::  application event
    ++  hive  ,[p=time q=path r=lens]         ::  identity and context
    ++  kiwi                                  ::  system product
      $%  [%o p=@ta q=*]                      ::  opaque output by app
          [%p p=@ud q=@ud r=tank]             ::  print session, tab, text
          [%w p=time]                         ::  request alarm
      ==
    ++  lamb                                  ::  system event
      $|  ~                                   ::  wakeup
      $%  [%d p=(list ,[p=term q=plum])]      ::  direct output
          [%e p=(list ,[p=term q=pork])]      ::  direct input
          [%l p=@ud q=@ta]                    ::  command line by session
      ==
    ++  lens                                  ::  query interface
      $_  ^?
      |%
      ++  pray  |+(path *(unit bill))         ::  specific query
      ++  hope  |+(quip *(list fact))         ::  series query
      ++  wish  |+(quip *(list case))         ::  sequence query
      --
    ++  plum                                  ::  process product
      $%  [%po p=path q=*]                    ::  post to sequence
          [%pu p=path q=*]                    ::  put in deck
          [%to p=@ta q=beef]                  ::  pass a command
          [%yo p=kiwi]                        ::  output
      ==
    ++  pork                                  ::  process event
      $|  ~                                   ::  no-op
      $%  [%do p=*]                           ::  direct command
          [%nu p=fact]                        ::  new fact
      ==
    ++  ship                                  ::  process
      $_  ^?  
      |%
      ++  film                                ::  special query
        |+  hap=path
        *(unit) 
      ::
      ++  step                                ::  operation
        |+  [hov=hive poc=pork]
        [p=*(list plum) q=^?(..step)]
      --  
    --
=>  #/+hull
|=  who=@h
=+  why=(rent %h who)
=+  dak=deck
=+  ^=  pod  ^-  (list ,[p=term q=ship])
    :~  [%bede (hull #/+bede)]
    ==
=>  |%                                        ::  internal devices
    ++  iris
      ^-  lens
      |%
      ++  pray  
        |=  [hap=path] 
        ^-  (unit bill)
        =+  nev=(mine:dak [~ ~] `quiz`hap)
        ?~  nev
          ~
        [~ q.i.nev]
      ::
      ++  hope
        |=  [wid=quid qex=quiz]
        ^-  (list fact)
        (mine:dak wid qex)
      ::
      ++  wish  
        |=  [wid=quid qex=quiz]
        ^-  (list case) 
        (plow:dak wid qex)
      --
    ++  post                                  ::  add to sequence
      |=  [now=time lap=path val=*]
      ^-  [p=fact q=_..post]
      =+  yam=(post:dak now lap val)
      :- [(flop `path`[(rent %ud p.yam) (flop lap)]) [now val]]
      ..post(dak q.yam)
    ::
    ++  putt                                  ::  write as state
      |=  [now=time lap=path val=*]
      ^-  [p=fact q=_..putt]
      :-  [lap [now val]]
      ..putt(dak (putt:dak now lap val))
    ::
    ++  save
      |=  [now=time pie=(list ,[p=@ta q=plum])]
      =+  lod=*(list fact)
      |-  ^+  [p=lod q=..save]
      ?~  pie
        [(flop lod) ..save]
      ?+    q.i.pie  $(pie t.pie)
          [%po *]  
        =+  von=(post now (weld [why ~] [p.i.pie p.q.i.pie]) q.q.i.pie)
        $(pie t.pie, lod [p.von lod], ..save q.von)
      ::
          [%pu *]
        =+  von=(putt now (weld [why ~] [p.i.pie p.q.i.pie]) q.q.i.pie)
        $(pie t.pie, lod [p.von lod], ..save q.von)
      ==
    ::
    ++  wick
      |=  :*  now=time
              vey=(list pork) 
              sun=(list ,[p=term q=pork]) 
          ==
      ^-  [p=(list kiwi) q=_..wick]
      %+  work  
        now
      |=  [now=time cam=lens nam=@ta ski=ship]
      ^-  [p=(list plum) q=ship]
      =+  ^=  bam
          %+  weld
            vey
          |-  ^-  (list pork)
          ?~(sun ~ =+(yec=$(sun t.sun) ?.(=(nam p.i.sun) yec [q.i.sun yec])))
      =+  yap=*(list (list plum))
      |-  ^-  [p=(list plum) q=ship]
      ?~  bam
        =+  pay=`_yap`(flop yap)
        :-  |-  ^-  (list plum)
            ?~  pay
              ~
            (weld i.pay $(pay t.pay))
        ski
      =+  rez=(step:ski [now [why nam ~] cam] i.bam)
      $(bam t.bam, yap [p.rez yap], ski q.rez)
    ::
    ++  wilt
      |=  [now=time pie=(list ,[p=term q=plum])]
      ^-  [p=(list kiwi) q=_..wilt]
      =+  vad=(save now pie)
      =>  ^+(. .(..work q.vad))
      =-  :-  |-  ^-  (list kiwi)
              ?~  pie
                p.gow
              =+  weg=$(pie t.pie)
              ?.(?=([%yo *] q.i.pie) weg [p.q.i.pie weg])
          q.gow
      ^=  gow
      %^    wick
          +(now)
        |-  ^-  (list pork)
        ?~(p.vad ~ [[%nu i.p.vad] $(p.vad t.p.vad)])
      |-  ^-  (list ,[p=term q=pork])
      ?~  pie 
        ~ 
      =+  der=$(pie t.pie)
      ?.(?=([%to *] q.i.pie) der [[p.i.pie [%do p.q.i.pie]] der])
    ::
    ++  work
      |=  :-  now=time 
          ^=  rap  $_  |+  [now=time cam=lens @ta ski=ship]
                       [p=*(list plum) q=*ship]
      ^-  [p=(list kiwi) q=_..work]
      =+  ^=  pan  ^-  (list ,[p=term q=(list plum) r=ship])
          %+  turn
            pod
          |=  a=[p=term q=ship]
          [p.a (rap now iris p.a q.a)]
      =>  ^+(. .(pod (turn pan |=(a=[p=term q=(list plum) r=ship] [p.a r.a]))))
      %+  wilt
        now
      |-  ^-  (list ,[p=term q=plum])
      ?~  pan
        ~
      |-  ^-  (list ,[p=term q=plum])
      ?~  q.i.pan
        ^$(pan t.pan)
      [[p.i.pan i.q.i.pan] $(q.i.pan t.q.i.pan)]
    --
|%                                            ::  external interface
++  flog
  |=  [now=time lab=lamb]  
  ^-  [p=(list kiwi) q=_..flog]
  =+  cro=|=(did=[p=(list kiwi) q=_..work] [p.did ..flog(..work q.did)])
  ?-    lab
      ~       (cro (wick now [[%do ~] ~] ~))
      [%d *]  (cro (wilt now p.lab))
      [%e *]  (cro (wick now ~ p.lab))
      [%l *]  $(lab [%e [[%bede [%do %line p.lab q.lab]] ~]])
  ==
::
++  read
  |=  [now=time hap=path]
  (pray:iris hap)
--
