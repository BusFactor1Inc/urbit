!:
::          %reck layer 0.  This file is in the public domain.
::
=>
  |%
  ++  ac  $_                                            ::  asym cryptosuite
    ^?  |%                                              ::  opaque object
    ++  de  |+([a=@ b=@] *(unit ,@))                    ::  symmetric de, soft
    ++  dy  |+([a=@ b=@] @)                             ::  symmetric de, hard
    ++  en  |+([a=@ b=@] @)                             ::  symmetric en
    ++  es  |+(a=@ @)                                   ::  step key to next
    ++  ex  ^?                                          ::  export
      |%  ++  fig  @uvH                                 ::  fingerprint
          ++  pub  *pass                                ::  public key
          ++  sec  *ring                                ::  private key
      --                                                ::
    ++  mx  @                                           ::  max direct bytes
    ++  nu  ^?                                          ::  reconstructors
      |%  ++  pit  |=([a=@ b=@] ^?(..nu))               ::  from [width seed]
          ++  nol  |=(a=@ ^?(..nu))                     ::  from naked ring
          ++  com  |=(a=@ ^?(..nu))                     ::  from naked pass
      --                                                ::
    ++  pu  ^?                                          ::  public-key acts
      |%  ++  seal  |=([a=@ b=@] [p=@ q=@])             ::  encrypt
          ++  sure  |=(a=@ *(unit ,@))                  ::  authenticate
      --                                                ::
    ++  se  ^?                                          ::  secret-key acts
      |%  ++  sign  |=(a=@ @)                           ::  certify
          ++  tear  |=(a=@ *(unit ,[p=@ q=@]))          ::  accept
      --
    --
  ::::
  ::
  ++  crya                                              ::  cryptosuite A (RSA)
    ^-  ac
    =+  [mos=@ pon=*(unit ,[p=@ q=@ r=[p=@ q=@] s=_*fu])]
    =>  |%
        ++  dap                                         ::  OEAP decode
          |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]
          =+  pav=(sub wid xar)
          =+  qoy=(cut 0 [xar pav] dog)
          =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))
          [dez (mix qoy (shaw %pad-a pav dez))]
        ::
        ++  pad                                         ::  OEAP encode
          |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @
          =+  pav=(sub wid p.rax)
          ?>  (gte pav (met 0 meg))
          ^-  @
          =+  qoy=(mix meg (shaw %pad-a pav q.rax))
          =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))
          (can 0 [p.rax dez] [pav qoy] ~)
        ::
        ++  pull  |=(a=@ (~(exp fo mos) 3 a))
        ++  push  |=(a=@ (~(exp fo mos) 5 a))
        ++  pump
          |=  a=@  ^-  @
          ?~  pon  !!
          (out.s.u.pon (exp.s.u.pon p.r.u.pon (sit.s.u.pon a)))
        ::
        ++  punt
          |=  a=@  ^-  @
          ?~  pon  !!
          (out.s.u.pon (exp.s.u.pon q.r.u.pon (sit.s.u.pon a)))
        --
    |%
    ++  de  
      |+  [key=@ cep=@]  ^-  (unit ,@)
      =+  toh=(met 8 cep)
      ?:  (lth toh 2)
        ~
      =+  adj=(dec toh)
      =+  [hax=(end 8 1 cep) bod=(rsh 8 1 cep)]
      =+  msg=(mix (~(raw og (mix hax key)) (mul 256 adj)) bod)
      ?.  =(hax (shax (mix key (shax (mix adj msg)))))
        ~
      [~ msg]
    ::
    ++  dy  |+([a=@ b=@] (need (de a b)))
    ++  en
      |+  [key=@ msg=@]  ^-  @ux
      =+  len=(met 8 msg)
      =+  adj=?:(=(0 len) 1 len)
      =+  hax=(shax (mix key (shax (mix adj msg))))
      (rap 8 hax (mix msg (~(raw og (mix hax key)) (mul 256 adj))) ~)
    ::
    ++  es  |+(a=@ (shas %anex a))
    ++  ex  ^?
      |%  ++  fig  ^-  @uvH  (shaf %afig mos)
          ++  pub  ^-  pass  (cat 3 'a' mos)
          ++  sec  ^-  ring  ?~(pon !! (cat 3 'A' (jam p.u.pon q.u.pon)))
      --
    ::
    ++  mx  (dec (met 0 mos))
    ++  nu  
      =>  |%
          ++  elcm
            |=  [a=@ b=@]
            (div (mul a b) d:(egcd a b))
          ::
          ++  eldm
            |=  [a=@ b=@ c=@]
            (~(inv fo (elcm (dec b) (dec c))) a)
          ::
          ++  ersa
            |=  [a=@ b=@]
            [a b [(eldm 3 a b) (eldm 5 a b)] (fu a b)]
          --
      ^?
      |%  ++  com
            |=  a=@
            ^+  ^?(..nu)
            ..nu(mos a, pon ~)
          ::
          ++  pit
            |=  [a=@ b=@]
            =+  c=(rsh 0 1 a)
            =+  [d=(ramp c [3 5 ~] b) e=(ramp c [3 5 ~] +(b))]
            ^+  ^?(..nu)
            ..nu(mos (mul d e), pon [~ (ersa d e)])
          ::
          ++  nol
            |=  a=@ 
            ^+  ^?(..nu)
            =+  b=((hard ,[p=@ q=@]) (cue a))
            ..nu(mos (mul p.b q.b), pon [~ (ersa p.b q.b)])
      --
    ++  pu  ^?
      |%  ++  seal
            |=  [a=@ b=@]
            ^-  [p=@ q=@]
            =+  det=(lte (add 256 (met 0 b)) mx)
            =+  lip=?:(det b 0)
            =+  hec=(cat 7 (shaf %acam lip) (shaf %asel a))
            =+  key=(shas %ales hec)
            :-  key
            =-  (add ?:(p.mav 0 1) (lsh 0 1 q.mav))
            ^=  mav  ^-  [p=? q=@]
            :-  det
            =+  dog=(pad mx [256 hec] lip)
            =+  hog=(push dog)
            =+  ben=(en key b)
            ?:(det hog (jam hog ben))
          ::
          ++  sure
            |=  a=@
            ^-  (unit ,@)
            =+  [det==(0 (end 0 1 a)) bod=(rsh 0 1 a)]
            =+  gox=?:(det [p=bod q=0] ((hard ,[p=@ q=@]) (cue bod)))
            =+  dog=(pull p.gox)
            =+  pig=(dap mx 128 dog)
            =+  log=?:(det q.pig q.gox)
            ?.(=(p.pig (shaf %agis log)) ~ [~ log])
      --
    ++  se  ^?
      |%  ++  sign
            |=  a=@  ^-  @
            =-  (add ?:(p.mav 0 1) (lsh 0 1 q.mav))
            ^=  mav  ^-  [p=? q=@]
            =+  det=(lte (add 128 (met 0 a)) mx)
            :-  det
            =+  hec=(shaf %agis a)
            =+  dog=(pad mx [128 hec] ?:(det a 0))
            =+  hog=(pump dog)
            ?:(det hog (jam hog a))
          ::
          ++  tear
            |=  a=@
            ^-  (unit ,[p=@ q=@])
            =+  [det==(0 (end 0 1 a)) bod=(rsh 0 1 a)]
            =+  gox=?:(det [p=bod q=0] ((hard ,[p=@ q=@]) (cue bod)))
            =+  dog=(punt p.gox)
            =+  pig=(dap mx 256 dog)
            =+  mac=(end 7 1 p.pig)
            ?.  =(mac (shaf %acam q.pig))
              ~
            =+  key=(shas %ales p.pig)
            ?:  det 
              [~ key q.pig]
            =+  cow=(de key q.gox)
            ?~(cow ~ [~ key u.cow])
      --
    --
  ++  brew                                              ::  create keypair
    |=  [a=@ b=@]                                       ::  width seed
    ^-  ac
    (pit:nu:crya a b)
  ::
  ++  hail                                              ::  activate public key
    |=  a=pass
    ^-  ac
    =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
    ?>  =('a' mag)
    (com:nu:crya bod)
  ::
  ++  wear                                              ::  activate secret key
    |=  a=ring
    ^-  ac
    =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
    ?>  =('A' mag)
    (nol:nu:crya bod)
  ::::
  ::
  ++  test-rsa
    |=  msg=@tas
    ^-  @
    =+  rsa=(brew 1.024 (shax msg))
    =+  [sal=(shax (shax msg)) key=(shax (shax (shax msg)))]
    =+  sax=(seal:pu:rsa sal msg)
    =+  tin=(tear:se:rsa q.sax)
    ?.  &(?=(^ tin) =(p.sax p.u.tin) =(msg q.u.tin))
      ~|(%test-fail-seal !!)
    =+  tef=(sign:se:rsa msg)
    =+  lov=(sure:pu:rsa tef)
    ?.  &(?=(^ lov) =(msg u.lov))
      ~|(%test-fail-sign !!)
    msg
  --  
=>  |%
    ++  base  ,@p                                       ::  host identity
    ++  bath  ,[p=@tas q=hand]                          ::  host note id
    ++  bird  ,[p=@da q=rock]                           ::  packet in flight
    ++  bond  (list post)                               ::  atomic statement
    ++  code  ,@uvI                                     ::  symmetric key
    ++  deed  ,[p=base q=mark r=@uw s=pass]             ::  ownership stage
    ++  cask                                            ::  symmetric record
              $:  yed=(unit ,[p=hand q=code])           ::  outbound
                  heg=(map hand code)                   ::  proposed 
                  qim=(map hand code)                   ::  inbound
              ==                                        ::
    ++  door                                            ::  foreign contact
              $:  
                  wod=road                              ::  connection to
                  fer=road                              ::  inferred conn from
                  caq=cask                              ::  network state
              ==                                        ::
    ++  flap  ,@uvI                                     ::  fragment name
    ++  flow                                            ::  packet connection
              $:  liz=@da                               ::  last receipt
                  rtt=@dr                               ::  round trip time
                  rat=@ud                               ::  rtt bytes/sec
              ==                                        ::
    ++  gram  ,@uw                                      ::  physical datagram
    ++  hair                                            ::  logical datagram
              $%  [& p=@]                               ::  log13 atom
                  [| p=@ud q=(list hair)]               ::  width/13 frags  
              ==                                        ::
    ++  host                                            ::  captive server
              $:  hom=lane                              ::  public route
                  cyl=(map base pipe)                   ::  clients
              ==                                        ::
    ++  hand  ,@uvI                                     ::  hash of code
    ++  hole  $%([& p=flap] [| p=sock q=well])          ::  flap target
    ::  jack
    ++  lint  (list rock)                               ::  fragment array
    ++  lane                                            ::  packet route
              $%  [%if p=@ud q=@if]                     ::  IPv4 UDP/addr
                  [%is p=@ud q=@is]                     ::  IPv6 UDP/addr
              ==                                        ::
    ++  link  ,[p=code q=sock]                          ::  connection
    ++  mace  (list ,[p=mark q=ring])                   ::  secret history
    ++  tray                                            ::  fragment pile
              $:  zep=@da                               ::  last receipt
                  key=code                              ::  encryption
                  loz=hole                              ::  meaning
                  yoo=(list flap)                       ::  assembly
                  hym=[p=@ q=(map flap (unit rock))]    ::  awaiting
              ==                                        ::
    ++  mark  ,@ud                                      ::  regime number
    ++  mitt                                            ::  incoming message
              $:  zep=@da                               ::  last active
                  dyq=well                              ::  note identity
                  vuf=flap                              ::  content fragment
                  gux=code                              ::  content key
              ==                                        ::
    ++  pipe                                            ::  neighbor
              $:  wiz=@da                               ::  next activation
                  syn=(unit flow)                       ::  route & congestion
                  fus=(map well mitt)                   ::  inbound messages
                  lyd=(map well putt)                   ::  outbound messages
                  huv=(map hand bird)                   ::  outbound packets
              ==                                        ::
    ++  plan                                            ::  protocol
              $?  %back                                 ::  acknowledgment
                  %buck                                 ::  crypto master 
                  %fast                                 ::  shared key
                  %full                                 ::  signed and sealed
                  %open                                 ::  signed only
                  %leaf                                 ::  fragment
              ==                                        ::
    ++  post  ,[p=path q=*]                             ::  statement
    ++  putt                                            ::  incoming message
              $:  wiz=@da                               ::  next activation
                  cha=bath                              ::  event identity
                  wyv=(gear rock)                       ::  packet generator
              ==                                        ::
    ++  rank  ?(%czar %king %duke %earl %pawn)          ::  base width class
    ++  road                                            ::  secured oneway route
              $:  exp=@da                               ::  expiration date
                  lue=(unit lane)                       ::  route to friend
                  lew=will                              ::  will of friend
              ==
    ++  rock  ,@uvO                                     ::  packet
    ++  safe                                            ::  domestic host
              $:  loc=(unit lane)                       ::  packet route
                  val=wand                              ::  private keys
                  law=will                              ::  server will
                  hoc=(map base door)                   ::  friends & relations
              ==                                        ::
    ++  salt  ,@uv                                      ::  entropy
    ++  sock  ,[p=base q=base]                          ::  from to
    ++  taxi  ,[p=lane q=rock]                          ::  routed packet
    ++  town                                            ::  all security state
              $:  lit=@ud                               ::  active modulus
                  urb=(map base safe)                   ::  all keys and routes
              ==
    ++  wand  (list ,[p=mark q=ac])                     ::  mace in action
    ++  weft  (list flap)                               ::  fragment probe
    ++  well  ,@uvI                                     ::  network note id
    ++  will  (list deed)                               ::  certificate
    ++  host                                            ::  private server
              $:  hom=lane                              ::  public route
                  cyl=(map base pipe)                   ::  clients
              ==
    --
=>  |%
    ::::
    ++  go
      |_  ton=town
      ::::
      ++  as
        |_  [our=base saf=safe]
        ::::
        ++  ax
          |_  [her=base nob=door]
          ::::
          ++  cli                                       ::  client crypto
            ^-  [p=mark q=ac]
            ?~  lew.wod.nob  !!
            [q.i.lew.wod.nob (hail s.i.lew.wod.nob)]
          ::
          ++  kuc                                       ::  process key tag
            |=  had=hand
            ^-  (unit ,[p=code q=_..kuc])
            =+  wey=(~(get by heg.caq.nob) had)
            ?^  wey
              =+  key=(shas %anex u.wey)
              :+  ~  key
              %=    ..kuc
                  yed.caq.nob  [~ had u.wey]
                  heg.caq.nob  (~(del by heg.caq.nob) had)
                  qim.caq.nob  (~(put by qim.caq.nob) had key)
              ==
            =+  duv=(~(get by qim.caq.nob) had)
            ?~  duv  ~
            [~ u.duv ..kuc]
          --
        ::
        ++  ux
          |=  her=base
          ^+  ax
          =+  fod=(~(get by hoc.saf) her)
          ~(. ax [her ?~(fod *door u.fod)])
        ::
        ++  xu
          |=  new=_ax
          ^+  ..xu
          ..xu(hoc.saf (~(put by hoc.saf) her.new nob.new))
        ::::
        ::
        ++  sev  ?~(val.saf !! i.val.saf)                 ::  server crypto
        --
      ++  su
        |=  new=_as
        ^+  ..su
        ..su(urb.ton (~(put by urb.ton) our.new saf.new))
      ::
      ++  us
        |=  our=base
        ^+  as
        ~(. as [our (need (~(get by urb.ton) our))])
      --
    --
|%
++  zuul
  !!
--
