!:
?>  ?=(@ .)
%.  .
=<  dec
=>  222
=>  
  ::::
  ::::  Tier 0, kernel stub
  ::::
  ~%    %k.222  
      ~
    ~
  &.
  ++  stub  222
  ++  bit   {& |}
  ++  nap   |=(a=* a)
  ++  num   |=(a=* ^:(0* a))
  ++  rat   |=(a=* ^:(@ a))
  --
=>                                                    ::  Tier 1
  ~%    %a
      -
    ~
  &.
  ++  add
  ::::                                                ::  1a, basic math
    ~.  %add
    |=  [a=@ b=@] 
    ^-  @
    ?:  =(0 a)
      b
    $(a (dec a), b +(b))
  ::
  ++  dec
    ~.  %dec
    |=  a=@
    ~|  %dec
    ^-  @
    ?<  =(0 a)
    =+  b=@
    |-
    ?:  =(a +(b))
      b
    $(b +(b))
  ::
  ++  dum
    |=  a=@
    ^-  @
    ?<  =(0 a)
    =+  b=@
    |-
    ?:  =(a +(b))
      b
    $(b +(b))
  ::
  ++  div
    ~.  %div
    |=  [a=@ b=@]
    ^-  @
    ~|  %div
    ?<  =(0 b)
    =+  c=@
    |-
    ?:  (lth a b)
      c
    $(a (sub a b), c +(c))
  ::
  ++  gte
    ~.  %gte
    |=  [a=@ b=@]
    ^-  ?
    !(lth a b)
  ::
  ++  gth
    ~.  %gth
    |=  [a=@ b=@]
    ^-  ?
    !(lte a b)
  ::
  ++  lte
    ~.  %lte
    |=  [a=@ b=@]
    ?|(=(a b) (lth a b))
  ::
  ++  lth
    ~.  %lth
    |=  [a=@ b=@]
    ^-  ?
    &(!=(a b) |-(|(=(0 a) &(!=(0 b) $(a (dec a), b (dec b))))))
  ::
  ++  max
    ~.  %max
    |=  [a=@ b=@]
    ^-  @
    ?:  (gth a b)
      a
    b
  ::
  ++  min
    ~.  %min
    |=  [a=@ b=@]
    ^-  @
    ?:  (lth a b)
      a
    b
  ::
  ++  mod
    ~.  %mod
    |=  [a=@ b=@]
    ^-  @
    ?<  =(0 b)
    (sub a (mul b (div a b)))
  ::
  ++  mul
    ~.  %mul
    |=  [a=@ b=@]
    ^-  @
    =+  c=@
    |-
    ?:  =(0 a)
      c
    $(a (dec a), c (add b c))
  ::
  ++  sub
    ~.  %sub
    |=  [a=@ b=@]
    ~|  sub
    ^-  @
    ?:  =(0 b)
      a
    $(a (dec a), b (dec b))
  ::
  ::  Tier 2 constructs
  ::
  ++  list
    |*  a=nap
    $=(~ [i=(a) t=((list a))])
  ::
  ++  tree
    |*  a=nap
    $=(~ [n=(a) l=((tree a)) r=((tree a))])
  ::
  ++  unit
    |*  a=nap
    $=(~ [~ u=(a)])
  ::::
  --
=>
  ::::
  ::::  Tier 2, lists and units
  ::::
  ~%    %b
      -
    ~
  &.
  ::::                                                  Tier 2a, units
  ++  bind
    ~.  %bind 
    |*  [a=*(unit) b=nap]
    ?~  a
      ~
    [~ u=(b u.a)]
  ::
  ++  clap
    ~.  %clap
    |*  [a=*(unit) b=*(unit) c=|=(^ ->-)]
    ?~  a
      b
    ?~  b
      a
    [~ u=(c u.a u.b)]
  ::
  ++  drop
    ~.  %drop
    |*  a=*(unit)
    ?~  a
      ~
    [i=u.a t=~]
  ::
  ++  mate
    |*  [a=*(unit) b=*(unit)]
    ?~  b
      a
    ?~  a
      b
    ?.(=(u.a u.b) ~|('mate' !!) a)
  ::
  ++  need
    ~.  %need
    |*  a=*(unit)
    ?~  a
      !!
    u.a
  ::::                                                  Tier 2b, lists
  ::::
  ++  flop
    ~.  %flop
    |*  a=*(list)
    ^-  a
    =+  b=`a`~
    |-
    ?~  a
      b
    $(a t.a, b [i.a b])
  ::
  ++  homo
    |*  a=*(list)
    ^-  =<  $
        &.
          +-  $
            ?:  ?
              ~
            [i=(snag 0 a) t=$]
        --
    a
  ::
  ++  lent
    ~.  %lent
    |=  a=*(list)
    ^-  @
    =+  b=@
    |-
    ?~(a b $(a t.a, b +(b)))
  ::
  ++  levy
    ~.  %levy
    |*  [a=*(list) b=|=(p=* .?(p))]
    |-
    ^-  ?
    ?~  a
      &
    ?:  (b i.a)
      $(a t.a)
    |
  ::
  ++  lien
    ~.  %lien
    |*  [a=*(list) b=|=(p=* .?(p))]
    |-
    ^-  ?
    ?~  a
      |
    ?:  (b i.a)
      &
    $(a t.a)
  ::
  ++  reel
    ~.  %reel
    |*  [a=*(list) b==+([p=* q=*] |.(q))]
    |-
    ^-  q.b
    ?~  a
      q.b
    (b i.a $(a t.a))
  ::
  ++  roll
    ~.  %roll
    |*  [a=*(list) b==+([p=* q=*] |.(q))]
    |-
    ^-  q.b
    ?~  a
      q.b
    $(a t.a, b b(q (b i.a q.b)))
  ::
  ++  skim
    ~.  %skim
    |*  [a=*(list) b=|=(p=* .?(p))]
    |-
    ^-  a
    ?~  a
      ~
    ?:((b i.a) [i.a $(a t.a)] $(a t.a))
  ::
  ++  skip
    ~.  %skip
    |*  [a=*(list) b=|=(p=* .?(p))]
    |-
    ^-  a
    ?~  a
      ~
    ?:((b i.a) $(a t.a) [i.a $(a t.a)])
  ::  
  ++  slag
    |*  [a=@ b=*(list)]
    ?~  b
      ~|('slag-fail' !!)
    ?:  =(0 a)
      b
    $(b t.b, a (dec a))
  ::
  ++  snag
    ~.  %snag
    |*  [a=@ b=*(list)]
    ?~  b
      ~|('snag-fail' !!)
    ?:  =(0 a)
      i.b
    $(b t.b, a (dec a))
  ::
  ++  sort
    ~.  %sort
    |*  [a=*(list) b=|=([p=* q=*] =(p q))]
    |-
    ^-  a
    ?~  a
      ~
    %+  weld
      $(a (skim t.a |=(c=i.a (b c i.a))))
    `t.a`[i.a $(a (skim t.a |=(c=i.a !(b c i.a))))]
  ::
  ++  turn
    ~.  %turn
    |*  [a=*(list) b=nap]
    |-
    ?~  a
      ~
    [i=(b i.a) t=$(a t.a)]
  ::
  ++  weld
    ~.  %weld
    |*  [a=*(list) b=*(list)]
    |-
    ^-  b
    ?~  a
      b
    [i.a $(a t.a)]
  ::
  ++  foo
    |=  a=*
    (sort ((list num) a) gth)
  ::::                                                  Tier 3 constructs
  ::::
  ++  axis  num
  ++  bloq  num
  ::::
  --
=>
  ::::
  ::::  Tier 3, noun surgery
  ::::
  ~%    %c
      -
    ==
      %far  far
      %fyr  fyr
    ==
  &.
  ::      Tier 3a, axes
  ::
  ++  cap
    ~.  %cap
    |=  [a=*axis]
    ^-  *{2 3}
    ?-    a
        2       2
        3       3
        *{0 1}  !!
        *       $(a (div a 2))
    ==
  ::
  ++  mas
    ~.  %mas
    |=  [a=*axis]
    ^-  *axis
    ?-  a
      1   !!
      2   1
      3   1
      *   (add (mod a 2) (mul $(a (div a 2)) 2))
    ==
  ::
  ++  peg
    ~.  %peg
    |=  [a=*axis b=*axis]
    ^-  *axis
    ?-  b
      1   a
      2   (mul a 2)
      3   +((mul a 2))
      *   (add (mod b 2) (mul $(b (div b 2)) 2))
    ==
  ::
  ::      Tier 3b, bit surgery
  ::
  ++  bex
    ~.  %bex
    |=  [a=@]
    ^-  @
    ?:  =(0 a)
      1
    (mul 2 $(a (dec a)))
  ::
  ++  can
    ~.  %can
    |=  [a=*bloq b=*(list ~[p=@ q=@])]
    ^-  @
    ?~  b
      0
    (mix (end a p.i.b q.i.b) (lsh a p.i.b $(b t.b)))
  ::
  ++  cat
    ~.  %cat
    |=  [a=*bloq b=@ c=@]
    (add (lsh a (met a b) c) b)
  ::
  ++  cut
    ~.  %cut
    |=  [a=*bloq [b=@ c=@] d=@]
    (end a c (rsh a b d))
  ::
  ++  end
    ~.  %end
    |=  [a=*bloq b=@ c=@]
    (mod c (bex (mul (bex a) b)))
  ::
  ++  lsh
    ~.  %lsh
    |=  [a=*bloq b=@ c=@]
    (mul (bex (mul (bex a) b)) c)
  ::
  ++  met
    ~.  %met
    |=  [a=*bloq b=@]
    ^-  @
    =+  c=0*
    |-
    ?:  =(0 b)
      c
    $(b (rsh a 1 b), c +(c))
  ::
  ++  rap
    ~.  %rap
    |=  [a=*bloq b=*(list rat)]
    ^-  @
    ?~  b
      0
    (cat a i.b $(b t.b))
  ::
  ++  rep
    ~.  %rep
    |=  [a=*bloq b=*(list rat)]
    ^-  @
    =+  c=0*
    |-
    ?~  b
      0
    (con (lsh a c (end a 1 i.b)) $(c +(c), b t.b))
  ::
  ++  rip
    ~.  %rip
    |=  [a=*bloq b=@]
    ^-  *(list num)
    ?:  =(0 b)
      ~
    [(end a 1 b) $(b (rsh a 1 b))]
  ::
  ++  rsh
    ~.  %rsh
    |=  [a=*bloq b=@ c=@]
    (div c (bex (mul (bex a) b)))
  ::
  ::      Tier 3c, bit logic
  ::
  ++  con
    ~.  %con
    |=  [a=@ b=@]
    =+  [c=0* d=0*]
    |-
    ?:  ?&(=(0 a) =(0 b))
      d
    %=  $
      a   (rsh 0 1 a)
      b   (rsh 0 1 b)
      c   +(c)
      d   (add d (lsh 0 c ?&(=(0 (end 0 1 a)) =(0 (end 0 1 b)))))
    ==
  ::
  ++  dis
    ~.  %dis
    |=  [a=@ b=@]
    =+  [c=@ d=@]
    |-
    ?:  ?|(=(0 a) =(0 b))
      d
    %=  $
      a   (rsh 0 1 a)
      b   (rsh 0 1 b)
      c   +(c)
      d   (add d (lsh 0 c ?|(=(0 (end 0 1 a)) =(0 (end 0 1 b)))))
    ==
  ::
  ++  mix
    ~.  %mix
    |=  [a=@ b=@]
    ^-  @
    =+  [c=0* d=0*]
    |-
    ?:  ?&(=(0 a) =(0 b))
      d
    %=  $
      a   (rsh 0 1 a)
      b   (rsh 0 1 b)
      c   +(c)
      d   (add d (lsh 0 c =((end 0 1 a) (end 0 1 b))))
    ==
  ::
  ::      Tier 3d, noun orders
  ::
  ++  aor
    ~.  %aor
    |=  [a=* b=*]
    ^-  ?
    ?:  =(a b)
      &
    ?.  ?=(@ a)
      ?.  ?=(@ b)
        ?:  =(-.a -.b)
          $(a +.a, b +.b)
        $(a -.a, b -.b)
      |
    ?.  ?=(@ b)
      &
    |-
    =+  [c=(end 3 1 a) d=(end 3 1 b)]
    ?:  =(c d)
      $(a (rsh 3 1 a), b (rsh 3 1 b)) 
    (lth c d)
  :: 
  ++  dor
    ~.  %dor
    |=  [a=* b=*]
    ^-  ?
    ?:  =(a b)
      &
    ?.  ?=(@ a)
      ?.  ?=(@ b)
        ?:  =(-.a -.b)
          $(a +.a, b +.b)
        $(a -.a, b -.a)
      |
    ?.  ?=(@ b)
      &
    (lth a b)
  ::
  ++  gor
    ~.  %gor
    |=  [a=* b=*]
    ^-  ?
    =+  [c=(mug a) d=(mug b)]
    ?:  =(c d)
      (dor a b)
    (lth c d)
  ::
  ++  hor
    ~.  %hor
    |=  [a=* b=*]
    ^-  ?
    ?:  ?=(@ a)
      ?:  ?=(@ b)
        (gor a b) 
      &
    ?:  ?=(@ b)
      |
    ?:  =(-.a -.b)
      (gor +.a +.b)
    (gor -.a -.b)
  ::
  ++  vor
    ~.  %vor
    |=  [a=* b=*]
    ^-  ?
    =+  [c=(mug (mug a)) d=(mug (mug b))]
    ?:  =(c d)
      (dor a b)
    (lth c d)
  ::
  ::      Tier 3e, insecure hashing
  ::
++  mug
    ~.  %mug
    |=  a=*
    ^-  @
    &-  ?.  ?=(@ a)
          =+  [b=$(a -.a) c=$(a +.a)]
          =+  d=(mix b (add (end 5 1 (lsh 3 1 c)) (rsh 3 3 c)))
          |-
          =+  e=(dis 0x7fffffff (chum d))
          ?:  =(0 e)
            $(d +(d))
          e
        =+  b=0x18d0a625*
        |-
        =+  c=(met 5 a)
        =+  d=0*
        =+  e=b
        |-
        ?:  =(d c)
          =+  f=(dis 0x7fffffff e)
          ?:  =(0 f)
            $$(b +(b))
          f
        $(d +(d), e (chum (mix e (cut 5 [d 1] a))))
    ::
    ++  chum
      |=  [b=@]
      =-  (end 5 1 c)
      ^=  c
      (dice 3 (dice 2 (dice 1 (dice 0 b))))
    ::
    ++  dice
      |=  [b=@ c=@]
      (mix c (sbox (cut 3 [b 1] c))) 
    ::
    ++  sbox
      |=  [b=@]
      =-  (cut 5 [b 1] c)
      ^=  c
      0x45bd2fb7\ /eec357b8\ /2ae29f22\ /bb412e03\ /08445336\ /52ca46d8\
       /76d680b9\ /b9e06f14\ /6f8b9c36\ /a53ef834\ /e3533b5b\ /c5cd423e\
       /0cfd4d14\ /12924b1a\ /3e77ee18\ /1804e2a5\ /75d9c4e1\ /6d4b9a3e\
       /5d56c751\ /12ad4163\ /b9df9e63\ /fbfbdac7\ /54464f51\ /4b72be7f\
       /180d4405\ /1b456773\ /5fb51d73\ /2d4774c2\ /381585e2\ /0209e49e\
       /52c0256a\ /6deac45d\ /3f55045c\ /40b92e52\ /5242aa7a\ /a47337b1\
       /bc816aba\ /4bbb0ecf\ /f82cb4ad\ /0bc99c47\ /78a5c74c\ /9182f20d\
       /7b941dc3\ /ff307dd2\ /fc36ca9d\ /0c32efad\ /b1c38ca7\ /b799e1be\
       /fd0dbfee\ /9887957d\ /70186f9e\ /31325eca\ /48f0ac44\ /c7eb6480\
       /ab1f9401\ /167cf21d\ /dce5b8fa\ /121c9f64\ /e95eacb5\ /c50dca03\
       /8b29fd75\ /875f1bb9\ /261c8938\ /3bf794dc\ /e4395998\ /1b06df20\
       /19c11553\ /eefbdb16\ /54447c57\ /f54a4761\ /bdf13b8c\ /88502921\
       /72553aee\ /c63a1157\ /03a1f284\ /f5b59c3c\ /96923c87\ /e2c0936d\
       /4f112d16\ /0f4c5845\ /1055a07d\ /d82afef8\ /72fb1b49\ /0fa54e14\
       /637d01f5\ /7fe89a8b\ /0617eda8\ /4354f3e7\ /712f6316\ /9036b901\
       /111a1094\ /70c78bcc\ /28329ab3\ /fdf004ca\ /2026a870\ /85ac98d2\
       /3f52439e\ /e030c8ed\ /a7589924\ /05af69ed\ /566dd09c\ /4237062e\
       /e9fc60eb\ /c415321c\ /ac4fc47f\ /b265b0ee\ /95cdc493\ /3beb6b4d\
       /e777884a\ /370f9e65\ /6a52c674\ /62dc97c6\ /e5d5238e\ /b6315b6a\
       /c845a9e2\ /026c78ab\ /13beec00\ /b3ed287a\ /a01ebf2b\ /b5c0da93\
       /deeedce8\ /3e5ec58d\ /e83350f0\ /e6ffe2fb\ /a3765510\ /37f42e48\
       /474c90cf\ /78eea53d\ /d10faca2\ /a9417956\ /7c600063\ /14187d04\
       /faffdd23\ /44844992\ /61f4a52d\ /a234566b\ /a46b9dd7\ /1a9d0bd3\
       /cf3e4033\ /b3bcada3\ /00f3ef4e\ /7367a5f9\ /5e24070c\ /1b973827\
       /5dcd3652\ /95b1eb1f\ /035857a4\ /c090c33b\ /5eba8280\ /475d8534\
       /7fb44be7\ /3bffc889\ /dbaf1fa2\ /948328b1\ /56a8a01c\ /6717fa39\
       /4c41d2c6\ /b3275702\ /51634e92\ /51a573dd\ /d3ea1b9d\ /be74ea0b\
       /9093fa5f\ /d2e1d0d1\ /8a1fd93a\ /8f1d0a6e\ /b7a9e735\ /deb0aa12\
       /48d76271\ /e808ec02\ /8e498a90\ /83539726\ /86c7973e\ /44337e55\
       /81f4f7ca\ /3052b642\ /873b540e\ /68d8efa2\ /18494012\ /decc1486\
       /29079afa\ /b81a7b1d\ /63dd42a0\ /3cab1b6f\ /713fffa2\ /08835b42\
       /6dd6f5f8\ /65a14a04\ /5eab8eac\ /2fe5b7f9\ /bbc96404\ /f593e52b\
       /b2078d1a\ /f192cbcd\ /c5e102b2\ /9187837c\ /bddd8a18\ /5caf8a56\
       /3b7aa391\ /88fd1802\ /1e458e1d\ /5f606388\ /513ce98d\ /aed1093b\
       /ae87124c\ /f537ea14\ /0f4bb673\ /cfbeae41\ /123e5e9f\ /e14077a2\
       /40acd8dc\ /103b81cf\ /683fa466\ /9b9e2cec\ /23171ec6\ /2ba16060\
       /d3bfabae\ /dd68fcd2\ /f60ee7be\ /f44c697e\ /7990bd4e\ /3ce83919\
       /bc457a9d\ /5022a039\ /a158b454\ /80722ba6\ /87652d85\ /e2ddee5a\
       /5c43205e\ /c62f6816\ /4c680e34\ /151f4b17\ /9570fa83\ /eb9f040e\
       /22b9bd9c\ /d156e14b\ /3a30bdd8\ /f00fc9e2\ /62bcfdef\ /da4952df\
       /0c100eda\ /ccffce0a\ /1994625d\ /b0cd88c6\ /766ff6ec\ /7c8f831a\
       /7824fff6\ /dee5b579\ /99267e88\ /f8820121\ /6220ecc5\ /f40f7a8d\
       /fe8c511a\ /a9afcd63\ /ba9cd382\ /352598d8
    --
  ::
  ::      Tier 3f, phonetic encoding
  ::
  ++  fal
    'bocmarbinwansamlitsighidfidlissogdirwacsabwissib\
    /rigsoldopmodfoglidhopdardorlorhodfolrintogsilmir\
    /holpaslacrovlivdalsatlibtabhanticpidtorbolfosdot\
    /losdilforpilramtirwintadbicdifrocwidbisdasmidlop\
    /rilnardapmolsanlocnovsitnidtipsicropwitnatpanmin\
    /ritpodmottamtolsavposnapnopsomfinfonbanporworsip\
    /ronnorbotwicsocwatdolmagpicdavbidbaltimtasmallig\
    /sivtagpadsaldivdactansidfabtarmonranniswolmispal\
    /lasdismaprabtobrollatlonnodnavfignomnibpagsopral\
    /bilhaddocridmocpacravripfaltodtiltinhapmicfanpat\
    /taclabmogsimsonpinlomrictapfirhasbosbatpochactid\
    /havsaplindibhosdabbitbarracparloddosbortochilmac\
    /tomdigfilfasmithobharmighinradmashalraslagfadtop\
    /mophabnilnosmilfopfardatnoldinhatnacrisfotribhoc\
    /nimlarfitwalrapsarnalmoslandondanladdovrivbacpol\
    /laptalpitnambonrostonfodponsovnocsorlavmatmipfap'
  ::
  ++  fyl
    'lesnecbudwessevpersutletfulpensytdurwepserwylsun\
    /rypsyxdyrnuphebpeglupdepdysputlughecryttyssydnex\
    /lunmeplutseppesdelsulpedtemledtulmetwenbynhexfeb\
    /pyldulhetmevruttylwydtepbesdexsefwycburderneppur\
    /rysrebdennutsubpetrulsynregtydsupsemwynrecmegnet\
    /secmulnymtevwebsummutnyxrextebfushepbenmuswyxsym\
    /selrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpel\
    /syptermebsetdutdegtexsurfeltudnuxruxrenwytnubmed\
    /lytdusnebrumtynseglyxpunresredfunrevrefmectedrus\
    /bexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermer\
    /tenlusnussyltecmexpubrymtucfyllepdebbermughuttun\
    /bylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmyl\
    /wedducfurfexnulluclennerlexrupnedlecrydlydfenwel\
    /nydhusrelrudneshesfetdesretdunlernyrsebhulryllud\
    /remlysfynwerrycsugnysnyllyndyndemluxfedsedbecmun\
    /lyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes'
  ::
  ++  fap
    |=  a=@
    ~|  %fap
    ?>  (lth a 256)
    (cut 3 [(mul 3 a) 3] fal) 
  ::
  ++  fyp
    |=  a=@
    ~|  %fyp
    ?>  (lth a 256)
    (cut 3 [(mul 3 a) 3] fyl)
  ::
  ++  far
    |=  a=@
    ~|  [%far a]
    =+  b=0*
    |-(?:(=(a (fap b)) b $(b +(b))))
  ::
  ++  fyr
    |=  a=@
    ~|  [%fyr a]
    =+  b=0*
    |-(?:(=(a (fyp b)) b $(b +(b))))
  ::
  ::      Tier 3g, lite number theory
  :: 
  ++  egcd                                              ::  schneier's egcd
    |=  [a=@ b=@]
    =+  si
    =+  [c=(sun a) d=(sun b)]
    =+  [u=[c=(sun 1) d=0*] v=[c=0* d=(sun 1)]]
    |-  ^-  [d=@ u=@ v=@]
    ?:  =(0 c) 
      [(abs d) d.u d.v]
    ::  ?>  ?&  =(c (sum (pro (sun a) c.u) (pro (sun b) c.v)))
    ::          =(d (sum (pro (sun a) d.u) (pro (sun b) d.v)))
    ::      == 
    =+  q=(fra d c) 
    %=  $
      c  (dif d (pro q c))
      d  c
      u  [(dif d.u (pro q c.u)) c.u]
      v  [(dif d.v (pro q c.v)) c.v]
    ==
  ::
  ++  elcm
    |=  [a=@ b=@]
    (div (mul a b) d:(egcd a b))
  ::
  ++  fe                                                ::  modulo bloq
    &=  a=*bloq
    ++  dif  |=([b=@ c=@] (sit (sub (add out (sit b)) (sit c))))
    ++  inv  |=(b=@ (sub (dec out) (sit b)))
    ++  net  |=  b=@  ^-  @
             =>  .(b (sit b))
             ?:  (lte a 3)
               b
             =+  c=(dec a) 
             %+  con
               (lsh c 1 $(a c, b (cut c [0 1] b)))
             $(a c, b (cut c [1 1] b))
    ++  out  (bex (bex a))
    ++  rol  |=  [b=@ c=@]  ^-  @
             =+  d=(sit c)
             =+  e=(bex a)
             =+  f=(mod b e)
             =+  g=(sub e f)
             (con (lsh 0 f (end 0 g d)) (rsh 0 g d))
    ++  ror  |=  [b=@ c=@]  ^-  @
             =+  d=(sit c)
             =+  e=(bex a)
             =+  f=(mod b e)
             =+  g=(sub e f)
             (con (rsh 0 f d) (lsh 0 g (end 0 f d)))
    ++  sum  |=([b=@ c=@] (sit (add b c)))
    ++  sit  |=(b=@ (end a 1 b))
    --
  ::
  ++  fo                                                ::  modulo prime
    &=  a=@
    ++  dif
      |=  [b=@ c=@]
      (sit (sub (add a b) c))
    ::
    ++  exp
      |=  [b=@ c=@]
      ?:  =(0 b)
        1*
      =+  d=$(b (rsh 0 1 b))
      =+  e=(pro d d)
      ?:(=(0 (end 0 1 b)) e (pro c e))
    ::
    ++  fra
      |=  [b=@ c=@]
      (pro b (inv c))
    ::
    ++  inv
      |=  b=@
      =+  c=(dul:si u:(egcd b a) a)
      c
    ::
    ++  pro
      |=  [b=@ c=@]
      (sit (mul b c))
    ::
    ++  sit
      |=  b=@
      (mod b a)
    ::
    ++  sum
      |=  [b=@ c=@]
      (sit (add b c))
    --
  ::
  ++  fu                                                ::  modulo (mul p q)
    |=  a=[p=@ q=@]
    =+  b=(~(inv fo p.a) (~(sit fo p.a) q.a))
    &.
    ++  dif
      |=  [c=[@ @] d=[@ @]]
      [(~(dif fo p.a) -.c -.d) (~(dif fo q.a) +.c +.d)]
    ::
    ++  exp
      |=  [c=@ d=[@ @]]
      :-  (~(exp fo p.a) (mod c (dec p.a)) -.d) 
      (~(exp fo q.a) (mod c (dec q.a)) +.d)
    ::
    ++  out                                             ::  garner's formula
      |=  c=[@ @]
      %+  add
        +.c
      (mul q.a (~(pro fo p.a) b (~(dif fo p.a) -.c (~(sit fo p.a) +.c))))
    ::
    ++  pro
      |=  [c=[@ @] d=[@ @]]
      [(~(pro fo p.a) -.c -.d) (~(pro fo q.a) +.c +.d)]
    ::
    ++  sum
      |=  [c=[@ @] d=[@ @]]
      [(~(sum fo p.a) -.c -.d) (~(sum fo q.a) +.c +.d)]
    ::
    ++  sit
      |=  c=@
      [(mod c p.a) (mod c q.a)]
    --
  ::
  ++  si
    &.
    ::::
    ++  abs  |=(a=@ (add (end 0 1 a) (rsh 0 1 a)))
    ++  new  |=([a=? b=@] ?:(a (lsh 0 1 b) ?:(=(0 b) 0 +((lsh 0 1 (dec b))))))
    ++  old  |=(a=@ [(syn a) (abs a)])
    ++  sun  |=(a=@ (lsh 0 1 a))
    ++  syn  |=(a=@ =(0 (end 0 1 a)))
    ::::
    ::::
    ++  sum
      |=  [a=@ b=@]
      ~|  %si-sum
      =+  [c=(old a) d=(old b)]
      ?:  -.c
        ?:  -.d
          (new & (add +.c +.d))
        ?:  (gte +.c +.d)
          (new & (sub +.c +.d))
        (new | (sub +.d +.c))
      ?:  -.d
        ?:  (gte +.c +.d)
          (new | (sub +.c +.d))
        (new & (sub +.d +.c))
      (new | (add +.c +.d))
    ::
    ++  dif
      |=  [a=@ b=@]
      (sum a (new !(syn b) (abs b)))
    ::
    ++  dul
      |=  [a=@ b=@]
      =+  c=(old a)
      ?:(-.c (mod +.c b) (sub b +.c))
    ::
    ++  fra
      |=  [a=@ b=@]
      (new =(0 (mix (syn a) (syn b))) (div (abs a) (abs b)))
    ::
    ++  pro
      |=  [a=@ b=@]
      ~|  %si-pro
      (new =(0 (mix (syn a) (syn b))) (mul (abs a) (abs b)))
    ::
    ++  rem
      |=  [a=@ b=@]
      ~|  %si-rem
      (dif a (pro b (fra a b)))
    ::::
    --
  ::
  ::  Tier 4 constructs
  ::
  ++  apt
    |=  a=*(tree)
    ?~  a 
      & 
    ?&  ?~(l.a & ?&((vor n.a n.l.a) (hor n.l.a n.a)))
        ?~(r.a & ?&((vor n.a n.r.a) (hor n.a n.r.a)))
    ==
  ::
  ++  ept
    |=  a=*(tree ~[p=* q=*])
    ?~  a 
      & 
    ?&  ?~(l.a & ?&((vor p.n.a p.n.l.a) (hor p.n.l.a p.n.a)))
        ?~(r.a & ?&((vor p.n.a p.n.r.a) (hor p.n.a p.n.r.a)))
    ==
  ::
  ++  set
    |*  a=nap
    ::  $=(~ ^<(apt [n=(a) l=((set a)) r=((set a))]))
    $=(~ [n=(a) l=((set a)) r=((set a))])
  ::
  ++  map   
    |*  [a=nap b=nap]
    ::  $=(~ ^<(ept [n=[p=(a) q=(b)] l=((map a b)) r=((map a b))]))
    $=(~ [n=[p=(a) q=(b)] l=((map a b)) r=((map a b))])
  --
=>
  ::::
  ::::  Tier 4, containers
  ::::
  ~%    %d
      -
    ~
  &.
  ::      Tier 4a, sets
  ::
  ++  in
    ~.  %in
    &=  a=*(set)
    +-  all
      ~.  %all
      |*  b=|=(* ?)
      |-  ^-  ?
      ?~  a
        &
      ?&((b n.a) $(a l.a) $(a r.a))
    ::
    +-  any
      ~.  %any
      |*  b=|=(* ?)
      |-  ^-  ?
      ?~  a
        |
      ?|((b n.a) $(a l.a) $(a r.a))
    ::
    +-  gas
      ~.  %gas
      |=  b=`*(list %{?>(?=(^ a) n.a)})`~
      |-  ^-  a
      ?~  b
        a
      $(b t.b, a (put i.b))
    ::
    +-  has
      ~.  %has
      |*  b=*
      |-  ^-  ?
      ?~  a
        |
      ?:  =(b n.a)
        &
      ?:  (hor b n.a)
        $(a l.a)
      $(a r.a)
    ::
    +-  put
      ~.  %put
      |*  b=*
      |-  ^-  a
      ?~  a
        ^<(apt [b ~ ~])
      ?:  =(b n.a)
        a
      ?:  (hor b n.a)
        =+  c=$(a l.a)
        ?>  ?=(^ c)
        ?:  (vor n.a n.c)
          ^<(apt [n.a c r.a])
        ^<(apt [n.c l.c ^<(apt [n.a r.c r.a])])
      =+  c=$(a r.a)
      ?>  ?=(^ c)
      ?:  (vor n.a n.c)
        ^<(apt [n.a l.a c])
      ^<(apt [n.c ^<(apt [n.a l.a l.c]) r.c])
    ::
    +-  tap
      ~.  %tap
      |=  b=`*(list %{?>(?=(^ a) n.a)})`~
      ^-  b
      ?~  a
        b
      $(a r.a, b [n.a $(a l.a)])
    --
  ::
  ::      Tier 4b, maps
  ::
  ++  by
    ~.  %by
    &=  a=*(map)
    +-  all
      ~.  %all
      |*  b=|=(* ?)
      |-  ^-  ?
      ?~  a
        &
      ?&((b q.n.a) $(a l.a) $(a r.a))
    ::
    +-  any
      ~.  %any
      |*  b=|=(* ?)
      |-  ^-  ?
      ?~  a
        |
      ?|((b q.n.a) $(a l.a) $(a r.a))
    ::
    +-  gas
      ~.  %gas
      |*  b=*(list %{[p=* q=*]})
      |-  ^-  a
      ?~  b
        a
      $(b t.b, a (put p.i.b q.i.b))
    ::
    +-  get
      ~.  %get
      |*  b=*
      |-  ^-  *%{~ [~ u=?>(?=(^ a) q.n.a)]}
      ?~  a
        ~
      ?:  =(b p.n.a)
        [~ u=q.n.a]
      ?:  (gor b p.n.a)
        $(a l.a)
      $(a r.a)
    ::
    +-  has
      ~.  %has
      |*  b=*
      !=(~ (get b))
    ::
    +-  put
      ~.  %put
      |*  [b=* c=*]
      |-  ^-  a
      ?~  a
        ^<(ept [[b c] ~ ~])
      ?:  =(b p.n.a)
        ?:  =(c q.n.a)
          a
        ^<(ept [[b c] l.a r.a])
      ?:  (gor b p.n.a)
        =+  d=$(a l.a)
        ?>  ?=(^ d)
        ?:  (vor n.a n.d)
          ^<(ept [n.a d r.a])
        ^<(ept [n.d l.d ^<(ept [n.a r.d r.a])])
      =+  d=$(a r.a)
      ?>  ?=(^ d)
      ?:  (vor n.a n.d)
        ^<(ept [n.a l.a d])
      ^<(ept [n.d ^<(ept [n.a l.a l.d]) r.d])
    ::
    +-  tap
      ~.  %tap
      |=  b=`*(list %{?>(?=(^ a) n.a)})`~
      ^-  b
      ?~  a
        b
      $(a r.a, b [n.a $(a l.a)])
    --
  ::
  ::  Tier 5 constructs
  ::
  ++  char  ~[''*]
  ++  clip  ~[p=(hair) q=(tape)]
  ++  edge  ~[p=(hair) q=((unit ~[p=* q=(clip)]))]
  ++  fact  ~[p=* q=*]
  ++  hair  ~[p=1* q=1*]
  ++  know  |*(veq=(edge) ?~(q.veq !! p.u.q.veq))
  ++  like  |*  a=nap
            |=  b=`*`[(hair) ~]
            :-  p=(hair -.b) 
            q=?~(+.b ~ [~ u=[p=(a +>-.b) q=[p=(hair -.b) q=(tape +.b)]]])
  ++  pork  nap
  ++  rock  num
  ++  ring  num
  ++  rule  |=(tub=(clip) `(edge)`[p.tub ~ ~ tub])
  ++  spot  ~[p=@ q=[p=[p=@ q=@] q=[p=@ q=@]]]
  ++  tank
    $^  [%leaf p=(tape)]
        [%palm p=[p=(tape) q=(tape) r=(tape) s=(tape)] q=((list tank))]
        [%rose p=[p=(tape) q=(tape) r=(tape)] q=((list tank))]
    ::  [%farm p=[p=(tape) q=(tape) r=(tape)] q=((list (list tank)))]
    ==
  ++  tape  (list char)
  ++  term  ~[%%*]
  ++  wall  (list tape)
  ++  wand  num
  --
=>
  ::::
  ::::  Tier 5, parsing and printing
  ::::
  ~%    %e
      -
    ~
  &.
  ::
  ::  Tier 5a/0, parsing: tracing
  ::
  ++  last  |=  [zyc=*hair naz=*hair]
            ^-  *hair
            ?:  =(p.zyc p.naz)
              ?:((gth q.zyc q.naz) zyc naz)
            ?:((gth p.zyc p.naz) zyc naz)
  ::
  ++  slip  |=  [weq=*char naz=*hair]
            ^-  *hair
            ?:(=(10 weq) [+(p.naz) 1] [p.naz +(q.naz)])
  ::
  ::      Tier 5a/1, parsing: custom processing
  ::
  ++  cold
    ~.  %cold
    |*  ^~  [cus=* sef=rule]
    ~.  %fun
    |=  tub=*clip
    =+  vex=(sef tub)
    ?~  q.vex
      vex
    [p=p.vex q=[~ u=[p=cus q=q.u.q.vex]]]
  ::
  ++  cook
    ~.  %cook
    |*  ^~  [poq=nap sef=rule]
    ~.  %fun
    |=  tub=*clip
    =+  vex=(sef tub)
    ?~  q.vex
      vex
    [p=p.vex q=[~ u=[p=(poq p.u.q.vex) q=q.u.q.vex]]]
  ::
  ++  easy
    ~.  %easy
    |*  huf=*
    ~.  %fun
    |=  tub=*clip
    ^-  *(like %{huf})
    [p=p.tub q=[~ u=[p=huf q=tub]]]
  ::
  ++  fail  |=(tub=*clip [p=p.tub q=~])
  ++  full
    |*  ^~  sef=rule
    |=  tub=*clip
    =+  vex=(sef tub)
    ?~(q.vex vex ?:(=(~ q.q.u.q.vex) vex [p=p.vex q=~]))
  ::
  ++  here
    ~.  %here
    |*  ^~  [hez=|=([a=*spot b=*] [a b]) sef=rule]
    ~.  %fun
    |=  tub=*clip
    =+  vex=(sef tub)
    ?~  q.vex
      vex
    [p=p.vex q=[~ u=[p=(hez [%% p.tub p.q.u.q.vex] p.u.q.vex) q=q.u.q.vex]]]
  ::
  ++  just
    ~.  %just
    |=  daf=*char
    ~.  %fun
    |=  tub=*clip
    ^-  *(like char)
    ?~  q.tub
      (fail tub) 
    ?.  =(daf i.q.tub)
      (fail tub)
    (next tub)
  ::
  ++  knee
    |*  ^~  [gar=* sef=^~(|.(rule))]
    |=  tub=*clip
    ^-  *(like %{gar})
    ((sef) tub)
  ::
  ++  mask
    ~.  %mask
    |=  bud=*(list char)
    ~.  %fun
    |=  tub=*clip
    ^-  *(like char)
    ?~  q.tub
      (fail tub) 
    ?.  (lien bud |=(a=*char =(i.q.tub a)))
      (fail tub)
    (next tub)
  ::
  ++  next
    |=  tub=*clip
    ^-  *(like char)
    ?~  q.tub
      (fail tub) 
    =+  zac=(slip i.q.tub p.tub) 
    [zac [~ i.q.tub [zac t.q.tub]]]
  ::
  ++  shim
    ~.  %shim
    |=  zep=[p=@ q=@]
    ~.  %fun
    |=  tub=*clip
    ^-  *(like char)
    ?~  q.tub
      (fail tub) 
    ?.  ?&((gte i.q.tub p.zep) (lte i.q.tub q.zep))
      (fail tub)
    (next tub)
  ::
  ++  stag
    ~.  %stag
    |*  ^~  [gob=* sef=rule]
    ~.  %fun
    |=  tub=*clip
    =+  vex=(sef tub)
    ?~  q.vex
      vex
    [p=p.vex q=[~ u=[p=[gob p.u.q.vex] q=q.u.q.vex]]]
  ::
  ++  stew
    ~.  %stew
    |*  ^~  leh=*(list ~[p=*%{@ [@ @]} q=*%{rule}])
    =>  .(leh `(homo leh)`leh)
    =+  ^=  wor
        |=  [ort=*%{@ [@ @]} wan=*%{@ [@ @]}]
        ?~  ort
          ?~(wan (lth ort wan) (lth ort -.wan))
        ?~(wan (lth +.ort wan) (lth +.ort -.wan))
    =+  ^=  hel
        =+  hel=`*(tree %{i.leh})`~
        |-  ^-  hel
        ?~  leh
          ~
        =+  yal=$(leh t.leh)
        |-  ^-  hel
        ?~  yal
          [i.leh ~ ~]
        ?:  (wor p.i.leh p.n.yal)
          =+  nuc=$(yal l.yal)
          ?>  ?=(^ nuc)
          ?:  (vor p.n.yal p.n.nuc)
            [n.yal nuc r.yal]
          [n.nuc l.nuc [n.yal r.nuc r.yal]]
        =+  nuc=$(yal r.yal)
        ?>  ?=(^ nuc)
        ?:  (vor p.n.yal p.n.nuc)
          [n.yal l.yal nuc]
        [n.nuc [n.yal l.yal l.nuc] r.nuc]
    ~%  %fun  ..$$  ~
    |=  tub=*clip
    ?~  q.tub
      (fail tub)
    |-
    ?~  hel
      (fail tub)
    ?:  ?~  p.n.hel
          =(p.n.hel i.q.tub)
        ?&((gte i.q.tub -.p.n.hel) (lte i.q.tub +.p.n.hel))
      ::  (q.n.hel [(slip i.q.tub p.tub) t.q.tub])
      (q.n.hel tub)
    ?:  (wor i.q.tub p.n.hel)
      $(hel l.hel)
    $(hel r.hel)
  ::
  ++  stir
    ~.  %stir
    |*  ^~  [rud=* raq=|*([a=* b=*] [a b]) fel=rule]
    ~.  %fun
    |=  tub=*clip 
    ^-  *(like %{rud})
    =+  vex=(fel tub) 
    ?~  q.vex
      [p.vex [~ rud tub]]
    =+  wag=$(tub q.u.q.vex)
    ?>  ?=(^ q.wag)
    [(last p.vex p.wag) [~ (raq p.u.q.vex p.u.q.wag) q.u.q.wag]]
  ::
  ::      Tier 5a/2, parsing: bolts
  ::
  ++  bend
    ~.  %bend
    |*  ^~  raq=|*([a=* b=*] [a b])
    ~.  %fun
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      vex 
    =+  yit=(sab q.u.q.vex)
    =+  yur=(last p.vex p.yit)
    ?~  q.yit
      [p=yur q=q.vex]
    [p=yur q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]
  ::
  ++  comp
    ~.  %comp
    |*  ^~  raq=|*([a=* b=*] [a b])
    ~.  %fun
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      vex
    =+  yit=(sab q.u.q.vex)
    =+  yur=(last p.vex p.yit)
    ?~  q.yit
      [p=yur q=q.yit]
    [p=yur q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]
  ::
  ++  glue
    ~.  %glue
    |*  ^~  bus=rule
    ~.  %fun
    |*  [vex=*edge sab=rule]
    (plug vex ;~(pfix bus sab))
  ::
  ++  pfix
    ~.  %pfix
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      vex
    =+  yit=(sab q.u.q.vex)
    [p=(last p.yit p.vex) q=q.yit]
  ::
  ++  plug
    ~.  %plug
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      vex
    =+  yit=(sab q.u.q.vex)
    =+  yur=(last p.vex p.yit)
    ?~  q.yit
      [p=yur q=q.yit]
    [p=yur q=[~ u=[p=[p.u.q.vex p.u.q.yit] q=q.u.q.yit]]]
  ::
  ++  pose
    ~.  %pose
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      =+  roq=(sab)
      [p=(last p.vex p.roq) q=q.roq]
    vex
  ::
  ++  sfix
    ~.  %sfix
    |*  ^~  [vex=*edge sab=rule]
    ?~  q.vex
      vex
    =+  yit=(sab q.u.q.vex)
    [p=(last p.vex p.yit) q=?~(q.yit ~ [~ u=[p=p.u.q.vex q=q.u.q.yit]])]
  ::
  ::      Tier 5a/3, parsing: rule composers
  ::
  ++  bass
    |*  ^~  [wuc=@ tyd=rule]
    %+  cook
      |=  waq=*(list rat)
      %+  roll
        waq
      =+([p=@ q=@] |.((add p (mul wuc q))))
    tyd
  ::
  ++  boss
    |*  ^~  [wuc=@ tyd=rule]
    %+  cook
      |=  waq=*(list rat)
      %+  reel
        waq
      =+([p=@ q=@] |.((add p (mul wuc q))))
    tyd
  ::
  ++  ifix
    |*  ^~  [fel=[p=rule q=rule] hof=rule]
    ;~(pfix p.fel ;~(sfix hof q.fel))
  ::
  ++  more
    |*  ^~  [bus=rule fel=rule]
    ;~(pose (most bus fel) (easy ~))
  ::
  ++  most
    |*  ^~  [bus=rule fel=rule]
    ;~(plug fel (star ;~(pfix bus fel)))
  ::
  ++  plus  |*(fel=rule ;~(plug fel (star fel)))
  ++  slug
    |*  [rud=* raq=|*([a=* b=*] [a b])]
    |*  [bus=rule fel=rule]
    ;~((comp raq) fel (stir rud raq ;~(pfix bus fel)))
  ::
  ++  star
    |*  ^~  fel=rule
    (stir `*(list %{(know *fel)})`~ |*([a=* b=*] [a b]) fel)
  ::
  ::      tier 5a/4, parsing: ascii characters
  ::
  ++  ace  (just ' ')
  ++  bar  (just '|')
  ++  bas  (just '\\')
  ++  cab  (just '_')
  ++  cen  (just '%')
  ++  col  (just ':')
  ++  com  (just ',')
  ++  doc  (just '"')
  ++  dot  (just '.')
  ++  fas  (just '/')
  ++  gal  (just '<')
  ++  gar  (just '>')
  ++  hax  (just '#')
  ++  hes  (just '$')
  ++  kel  (just '{')
  ++  ker  (just '}')
  ++  ket  (just '^')
  ++  lus  (just '+')
  ++  mus  (just '-')
  ++  soc  (just '\'')
  ++  pal  (just '(')
  ++  pam  (just '&')
  ++  par  (just ')')
  ++  pat  (just '@')
  ++  sig  (just '~')
  ++  tis  (just '=')
  ++  sel  (just '[')
  ++  sem  (just ';')
  ++  ser  (just ']')
  ++  tar  (just '*')
  ++  tec  (just '`')
  ++  wut  (just '?')
  ++  zap  (just '!')
  ::
  ::      tier 5a/5, parsing: ascii utilities
  ::
  ++  alf  ;~(pose low hig)
  ++  low  (shim 'a' 'z')
  ++  hig  (shim 'A' 'Z')
  ++  dem  (bass 10 (most ace low))
  --
.
