!:
::  cary (4c), revision control
::
|=  pit=vase
^-  vane
=>
  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ::              section 4cA, filesystem logic         ::
  ::
  |%
  ++  un                                                ::  per seat
    |=  [who=@p now=@da ruf=raft]
    =+  ^=  yar  ^-  room
        =+  yar=(~(get by ruf) who)
        ?~(yar *room u.yar)
    =|  byn=(list ,[p=wire q=rede])
    |%
    ++  de                                              ::  per desk
      |_  [buk=@ta saq=desk]
      ++  aeon                                          ::  mark to era
        |=  lok=mark
        ^-  (unit ,@ud)
        ?-    -.lok
            %da
          ?:  (gth p.lok now)  ~
          =+  deq=?:(=(0 let.saq) ~ [~ (dec let.saq)])
          |-  ^+  deq
          ?~  hit.saq  deq
          ?:  (gth p.lok p.i.hit.saq)  deq
          =+  nix=(dec let.saq)
          $(hit.saq t.hit.saq, let.saq nix, deq [~ nix])
        :: 
            %tas  (~(get by lab.saq) p.lok)
            %ud   ?:((gte p.lok let.saq) ~ [~ p.lok])
        ==
      ::
      ++  amor                                          ::  endpoint query
        |=  ren=?(%x %y %z)
        ^-  (unit ,*)
        ?-  ren
          %x  ?.(?=(& -.arc.saq) ~ [~ q.arc.saq])
          %y  :-  ~
              ?-  -.arc.saq
                &  [& p.arc.saq]
                |  (turn (~(tap by p.arc.saq) ~) |=([p=@ta *] p))
              ==
          %z  [~ arc.saq]
        ==
      ::
      ++  argo                                          ::  revert to era
        |=  oan=@ud
        ^+  +>
        ?>  (lth oan let.saq)
        ?:  =(oan (dec let.saq))  +>
        %=  $
          let.saq  (dec let.saq)
          hit.saq  t.hit.saq
          arc.saq  dark:(durn:ka:(ci arc.saq) q.i.hit.saq)
        ==
      ::
      ++  aver                                          ::  domestic read 
        |=  [ren=mare lok=mark way=path]
        ^-  (unit (unit ,*))
        =+  nao=(aeon lok)
        ::  ~&  [%aver buk lok nao]
        ?~  nao  ~
        :-  ~
        ?:  ?=(%w ren)
          ?.(?=(~ way) ~ [~ u.nao])
        =.  +>.$  (argo u.nao)
        (amor(arc.saq dark:(deny:ka:(ci arc.saq) way)) ren)
      ::
      ++  biff                                          ::  path subset
        |=  [yok=path gib=path]
        ^-  (unit path)
        ?~  yok  [~ gib]
        ?~  gib  ~
        ?.  =(i.yok i.gib)  ~
        $(yok t.yok, gib t.gib)
      ::
      ++  edit                                          ::  apply changeset
        |=  lav=ukay
        ^+  +>
        ::  ~&  [%edit buk lav]
        =+  wak=darn:(durn:ka:(ci arc.saq) lav)
        %=  +>.$
          arc.saq  q.wak
          let.saq  +(let.saq)
          hit.saq  :_(hit.saq [now p.wak lav])
        ==
      ::
      ++  zoot
        %_(..de dos.yar (~(put by dos.yar) buk saq))
      --
    ::
    ++  di
      |=  buk=@ta
      =+  ^=  saq  ^-  desk
          =+  saq=(~(get by dos.yar) buk)
          ?~(saq [[%| ~] 0 ~ ~ ~] u.saq)
      ~(. de buk saq)
    ::
    ++  zonk
      ^-  raft
      (~(put by ruf) who yar)
    --
  --
  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ::              section 4cA, filesystem vane          ::
  ::
  =|                                                    ::  instrument state
      $:  ruf=raft                                      ::  revision tree
      ==                                                ::
  |=  [now=@da eny=@ sky=||(* (unit))]                  ::  activate
  ^?                                                    ::  opaque core
  |%                                                    ::
  ++  beat                                              ::  update
    |=  [whu=(unit seat) tea=duct hen=wire fav=card]
    ^-  [p=(list move) q=vane]
    ?+    -.fav  ~&  [%cary-none fav]
                 !!
        %crud
      [[[whu [/d/ hen] %flog fav] ~] ..^$]
    ::
        %edit
      =.  whu  
          ?^  whu  whu
          ?.  =(%gold (adit hen))  ~
          [~ p.fav] 
      ?>  =(u.whu p.fav)
      :-  =+  one=~(rend co ~ %p u.whu)
          =+  two=(rip 3 q.fav)
          %+  turn
            r.fav
          |=  uke=ukaz  ^-  move
          =+  qua=~(ram re (dish:ut [~ %path] p.uke))
          =+  qui=?-(-.q.uke %del '-', %set ?:(=(0 q.q.uke) '+' ':'))
          [whu [/d/ hen] %flog %note qui %leaf "{one}/{two}{qua}"]
      %_(..^$ ruf zonk:zoot:(edit:(di:(un u.whu now ruf) q.fav) r.fav))
    ::
        %keep
      ::  [[%tell %0 %leaf "cary: home for {~(rend co ~ %p u.whu)}"] ~]
      [~ ..^$(ruf (~(put by ruf) u.whu *room))]
    ==
  ::
  ++  come  |=(old=vase (load old))
  ++  doze
    |=  [now=@da hen=wire]
    ^-  (unit ,@da)
    ~
  ::
  ++  flee  stay
  ::
  ++  load
    |=  new=vase
    ^-  vane
    ?.  (~(nest ut -:!>(ruf)) & p.new)
      ~|(%load-nest-cary !!)
    ..^$(ruf (raft q.new))
  ::
  ++  raze
    ^-  vane
    ..$(ruf *raft)
  ::
  ++  scry                                              ::  inspect
    |=  [our=seat ron=@tas his=seat lot=coin tyl=path]
    ^-  (unit)
    ?~  tyl  ~
    =+  poj=(slay i.tyl)
    ?.  ?=([~ %% %tas *] poj)  ~
    =+  luk=?.(?=(%% -.lot) ~ ((soft mark) p.lot))
    =+  run=((soft mare) ron)
    ?~  luk  ~
    ?~  run  ~
    =+  vyr=(aver:(di:(un our now ruf) q.p.u.poj) u.run u.luk t.tyl)
    ?~(vyr ~ u.vyr)
  ::
  ++  stay  `vase`!>(ruf)
  --
