Memory structure of zeno (the loom):

1. Layout

You may know the typical Unix process layout, in which heap
grows upward from low memory, and stack grows downward
from high memory.  The general advantage of this layout
is zero fragmentation: heap and stack can grow as far 
toward each other as possible, until they meet.

This design is independent of the actual structures that grow
from both ends of a linear address space.  We might just as
well have two heaps growing toward each other, or two stacks.

The loom allocator is the latter - two stacks, growing toward 
each other.  A stack is actually a more powerful structure 
than a heap; if you have a stack and you want a heap, you can
always push one on top of the stack.  If you have a heap
and you want a (contiguous) stack, you are SOL.

We call these opposed stacks "beams."  A loom is two symmetric
beams, one growing up from the bottom of memory, the other
growing down from the top. The obvious constraint is that the
beams must never cross.  The unused area between them may be of
any length and at any position.

(Again, a loom imposes no external fragmentation - it can use
its complete allocated segment.  Of course, loom programmers
can still leak internally within the beams.)

All loom addresses are word (32-bit) addresses.  The loom
pointer format can address 2^28 words, or 1GB, which is 
adequate for most light-duty programming tasks.  A "nit"
is a 28-bit word pointer in the loom.

A "ray" is a 29-bit word offset onto a beam.  If bit 29
is 0, the ray grows forward from 0 and is "west."  If bit
29 is 1, the ray grows backward from the end of the loom,
and is "east."

All u3 nouns are represented by the 32-bit word type "rat."
If bit 31 of a rat is 0, it is a "cat" - a direct atom.
Bits 0-30 of a cat are an unsigned 31-bit integer.

A rat can be a special value, u3_none - not a noun.  A
rat which is not u3_none is a "fox."

If bit 31 of a rat is 1, bits 0-28 are a ray which points
to an indirect noun - a "dog."  If bit 30 is 0, the dog is
a "pom" - an indirect cell.  If bit 30 is 1, the noun is a
"pug" - an indirect atom.

Bit 29 on a dog is set iff the dog has special information
behind the pointer, including but not limited to allocation
header (block and reference count).

Although poms and pugs cannot be referenced through C pointers,
because a ray is not a C pointer and requires specialized address
arithmetic, their shape is described by these simple structures:

      struct u3_cell {
        c3_w   mug_w;
        u3_ray hed_ray;
        u3_ray tel_ray;
      };

      struct u3_atom {
        c3_w mug_w;
        c3_w len_w;
        c3_w buf_w[0];
      };

"c3_w" and "u3_ray" are both uint32_t.  "buf_w" is really an
array of length "len_w", of course.

"mug_w" is a 31-bit insecure hash which matches the Watt (mug)
gate.  The mug is computed lazily, as we need it - 0 is an
out-of-band value.  It is useful not just in associative and
balanced trees, but also in simple functions like equality.  If
two dogs have the same mug, they may be different nouns; if they
have different mugs, they must be different nouns.

2. Allocation (simple)

Now we consider the loom's simple default allocation algorithm,
the "Seuss system."  This depends on

For allocation, a zeno loom contains four pointers: "bat," 
"hat," "cap" and "mat."

"bat," a nit, points to the first word in the east beam.

"hat" and "cap", rays, are the tops of two opposing stack
allocators, rays on opposite beams.  Either the hat is east
and the cap is west, or vice versa.

"mat" is a ray on the same beam as the cap, at or below it.

The loom is hence divided into three parts:

0               hat        cap    mat                  1GB
|                |          |      |                     | 
|->.....box.......---pad----**can**........box.........<-|
|                                                        | 
west                                                  east

The "pad" is unused memory.  The "box" is stable memory.  The
"can" is temporary memory.  Again, the loom is symmetric.  The
can is always on one side of the pad, but that side can be east
(as shown above), or west:

0               mat       cap     hat                  1GB
|                |         |       |                     | 
|->.....box.......***can****--pad--........box.........<-|
|                                                        | 
west                                                  east

The loom imposes a seniority restriction on all pointers.  Box is
senior to can.  A reference stored in the can may point into the
box, but a reference stored in the box cannot point into the can.

Since the box cannot point to the can, the can may be entirely
destroyed without any corruption of the box.  In general, the can
is used for temporary allocation - ie, future garbage.

So the programmer in this context has two allocation choices.
She can allocate garbage on the cap, or product on the hat.
Rather than the normal model of stack and heap, she has two stack
pointers - cap and hat - which grow toward each other.

In general, any function F is expected to produce its product as a
fragmentation-free block of nouns, allocated in the box (on the
hat), with pointers to older data in the box, but not of course
the can.  The can is expected to be reset after the call.  Thus
F is expected, as part of the calling convention, to pick up its
own garbage.

Two stacks seems like a lot of choices for the programmer, every
time she allocates a cell.  Actually, though, this choice can in
normal circumstances be made by the interpreter - because the
only memory management problem in acyclic functional programming
is composition.  

When computing F(x), zeno allocates product on the hat.  When
computing F(G(x)), zeno allocates product of G(x) on the cap, and
product of F(x) on the hat.  If F(x) uses unmodified product of
G(x), these must be copied from cap to hat.  For the product of
G(x) is, by definition, garbage.

And when computing F(G(H(x)))?  Sadly, the calculations that
produce garbage have a nasty tendency to allocate temporary nouns
of their own. 

zeno handles the H(x) problem by reversing the beams.  Let's work
through a simple example:

As we start:

0               hat        cap    mat                  1GB
|                |          |      |                     | 
|->...............----------*******....................<-|
|                                                        | 
west                                                  east

"." is permanent memory, the box; "*" is temporary memory, the
can; "-" is free memory, the pad.

Our goal is to allocate the product of F as ".", by pushing
the hat a couple of columns east.

First, we depart to compute G.  The product of G is "!", and is
allocated on the cap.  Not that G is hardcoded for this role, of
course - it allocates its product on the hat, like any function.
But we fool it by reversing the beams:

                old        old    old
0               hat        cap    mat                  1GB
|                |          |      |                     | 
|->...............????----!!*******....................<-|
|                |   |    |                              | 
west            mat cap  hat                          east
                now now  now

The product of G is "!".  The garbage of G - which is the
product of H - is "?".  How do we get H to allocate on the cap?
Reverse the beams again, of course.

We complete the subcalculation by retreating:

                old        old    old 
0               hat        cap    mat                  1GB
|                |          |      |                     | 
|->...............--------!!*******....................<-|
|                |        |        |                     | 
|               hat      cap      mat                 east
west            now      now      now                 

We have now computed G and placed its product on the cap.  So we
are ready to compute F, placing its product on the hat:

                old        old    old 
0               hat        cap    mat                  1GB
|                |          |      |                     | 
|->.................--------*******....................<-|
|                  |        |      |                     | 
west              hat      cap    mat                 east
                  now      now    now                  

Thus we have pushed the product of F, without any garbage,
on the hat.  This algorithm is optimal, except for the cost of
copying temporary results - which may vary from prohibitive to
negligible.

And if it is prohibitive?  As it often is?  The loom design,
while quite incompatible with many important algorithms, makes a
good top-level default, because it leaves an unfragmented block
in the middle of memory in which we can run any memory-management
algorithm at all.

Since nouns are acyclic, there is a straightforward candidate:
reference counting.  To use reference counting in Watt, use the
%hand hint to install a memory allocator, and the %stay hint to
prevent reversal of beams.

In this pattern, we revert to the normal Unix design: the hat is
the heap, and the cap is the stack.  Indirect nouns (dogs)
allocated on the hat acquire a memory header, with which they can
be freed if their reference count goes to 0.

One of the advantages of internal reference counting within a
loom is that, when reference counting is used locally for a funky
algorithm that would otherwise incur excessive copying costs, we
do not have to track references outside this computation.  This
avoids a large number of pointless, cache-busting memory writes.

To supply this feature, we use an additional pointer, "rut,"
to separate the box into two parts: peer memory (counted) and
senior memory (not counted).  We also maintain a free list,
"fre", of free blocks in the peer box.  The result:

                old         old    old 
0               hat         cap    mat                  1GB
|                |           |      |                     | 
|->...............:::=:=::---*******....................<-|
|                |   |   |   |      |                     | 
west            rut fre hat cap    mat                 east
                now now now now    now           

Senior memory is "."; peer memory, allocated, is ":"; peer
memory, free, is "=".  If there is no adequate block on the free
list, the allocator will of course extend the hat.

So the Watt programmer has three allocation hints to provide.
These are %stay (to turn depart off), %flee (to turn it back on), 
and %free (to turn on reference counting).  Like all hints, these
do not affect program semantics, but they do affect efficiency.
